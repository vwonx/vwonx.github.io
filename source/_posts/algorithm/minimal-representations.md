---
title: 最小表示法
subtitle: 用于快速寻找循环同构字符串集中字典序最小的字符串
catalog: true
tags: 
  - 算法-字符串
categories:
  - 算法
abbrlink: 83fb8ed6
date: 2022-08-17 23:02:42
---
# 最小表示法

当字符串首尾相连，则从任一下标开始均可遍历完整个字符串。称这些从不同下标开始得到的字符串为 **循环同构**，而其中字典序最小的字符串称为**最小表示**。

# 数学定义

有一个长度为 $n$ 的字符串 $S$ ，则其所构成的循环同构字符串集合 $T$ 可以表示为：

$$
T = \{ S\left [ i...n \right ] + S\left [ 1...i-1\right ] \mid 1\le i\le n \}
$$

其中集合 $T$ 中字典序最小的字符串，为**最小表示字符串**。

# 算法核心

设由 $T$ 中得到两个字符串，其分别通过原字符串 $S$ 下标 $i$ 和 $j$ 作为起始位置得到，并且它们的前 $k$ 个字符相同，既有：

$$
S[i...i+k-1]=S[j...j+k-1]
$$

则对于下一个位置的判断有三种情况：

1. $S[i+k]>S[j+k]$，显然以 $i$ 作为起始位置的字符串并不是最小表示，并且也表明了以 $i+1$ 至 $i+k$ 为起始位置得到的字符串都不会是最小表示。这是因为二个字符串的前 $k$ 个字符相同，那么任何一个 $j+p (1 \le p \le k)$ 作为起始位置的字符串均小于 $i+p (1 \le p \le k)$ 作为起始位置得到的字符串。因此，在下一次比较的时候，$i$ 可以直接跳转到下标 $i+k+1$，以继续进行比较。
2. $S[i+k]<S[j+k]$，与上面同理，$j$ 可以直接跳转到下标 $j+k+1$，以继续进行比较。
3. $S[i+k]=S[j+k]$，直接继续判断下一个位置，即 $k+1$。

由于在不相等的时候，下标会直接跳过前k个位置。

因此 $i$ 或者 $j$ 只会遍历字符串一遍，时间复杂度为 $O(n)$  

# 算法步骤

1. 初始化下标和匹配长度为： $i=0, j=1, k=0$。
2. 分别比较 $i+k$ 和 $j+k$ 位置字符的大小，根据结果进行跳转。若跳转后的 $i$ 与 $j$ 相等，则可以将任意一个下标加一，以确保比较的两个字符串是不同的字符串。
3. 重复操作2，直到比较结束。
4. 由于比较过程中，较大的一方的下标会往后移动，因此，最终答案为 $i$ 和 $j$ 中较小的那一个。

# 代码

```cpp
int len = s.size();
int i = 0, j = 1, k = 0;
while(k<len && i < len && j < len) {
    if(s[(i+k)%len] == s[(j+k)%len]) ++k;
    else {
        s[(i+k)%len] > s[(j+k)%len]? i=i+k+1 : j=j+k+1;
        if(i == j) ++i;
        k = 0;
    }
}
int ans = min(i, j);
```
